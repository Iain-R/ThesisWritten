%!TEX root = ../main.tex

%FLUFF THE INTRO
\section{Modelling}
Modelling of a real world system has two motivators, the first is to gather better understanding of the system through mathematics and data analysis, the other is to allow operations such as optimisation and simulation onto the system. However there are challenges that can affect the accuracy of the model, as such careful deliberation should be taken to make good assumptions and simplifications. The assumptions and simplifications that are made will be explained and justified for each relevant algorithm, sub-model and constraint; all of which are needed to properly communicate the model in such a way that is independent of the optimisation techniques used.  
\\
The models defined in this section of the report will be used in all optimisation methods attempted, the accuracy of these models is vital to the accuracy of any formulation dependant on them and as such proper considerations and justifications must be made. The models that are discussed here are inherit to the system, they are often constants or functions within larger problem formulations, as such they are simple to change but yet key to the accuracy of the thesis. \\
The models discussed here are broken into four major sections, proper modelling of spoil distribution, modelling of movement patterns within a block, modelling of data unique to a dragline and finally the modelling of an action. Each of these categories aligns with a specific section of a formulation, and as such can be developed independently of each other. 
\subsection{Spoil modelling}
The Spoil or overburden is the strictest constraint on the feasblitly of a strip, as such the modelling of spoil distribution is vital to the accuracy of a model. The spoil channel can be discretised into sections with a given maximum capacity per section, following this the swell rate of the spoil and expansion factor due to inefficient spoil placement should also be considered. These three models are the required knowledge to properly consider and implement spoil capacity constraints on a formulation, each model can be seen below. 
\subsubsection{Spoil Capacity}
The capacity of a section of spoil is a vital constraint in the formulation of a block model, the capacity of the spoil is therefore modelled as the maximum amount of spoil that could stability be held at that section without collapse of the spoil channel, the stable angle for loose overburden to be stacked is 36 degree, with the spoil channel 20m lower than that of the mine therefore by using an approximate model of a cone to represent each spoil section, then the spoil capacity is $0.33\times W^2/2 \times H $ is the maximum spoil capacity. 
\subsubsection{Swell Factor}
Swell factor is the amount attributed to the swelling of overburden as it decompresses from its compacted pre mined state, this is found in textbooks and for a typical soil type of compact dirt can be modelled as an increase in volume of 30\%. The modelling taken from prior resources such as textbooks is sufficient for the purposes of this thesis 
% \subsection{Movement through a Block}

	
% \subsection{Dragline Dynamics}

% \subsection{Action Cost}

\section{Optimisation at the Block Level}
In order to model a sequence of blocks it is vital to first develop an accurate model describing the cost and spoil of a block, several methods were considered, each of which was an optimisation problem seeking to minimise the time taken to process the block. The calculation and modelling of a block must be rapid, as this modelling function will be used thousands of times in the calculation of a strip, while storing block costs into memory was originally considered the feasibility and cost of a block varies with three inputs, its start and end locations, and the current state of the spoil. Therefore the amount of unique blocks that can be considered is huge and storing results in memory loses efficiency \\A variety of methods were formulated and the results were compared against one another for both run time and accuracy, in order to verify the accuracy of a model its output is compared to techniques that are outlined in sections \ref{PA:MIP}, \ref{PA:DP} and \ref{PA:GA}. This comparison was done on both real world data and standard data sets that were generated for the purpose of testing. The comparison will focus on the run times of each solution as well as the accuracy of the method proposed. 

\subsection{Mixed Integer Programming}
Mixed Integer Programming is a somewhat obvious choice for this model, as this technique is already applied in a 3 dimensional environment as outlined in section\ref{PA:MIP}, however some changes must be made for this model to be used with the modified density data, as a result while the concept of a MIP was still considered, the problem itself had to be reformulated. Formulation for the model is found in the following section, while developing a MIP it is vital that all constraints and objectives are linearly related to data and variables, otherwise the solver algorithms will not work. The process of formulating an appropriate model for the block cost is based on the physical movements of a dragline and the constraints that will affect it, while some elements of the formulation were adjusted or ignored, the end formulation is the most accurate model with the data available. 
\subsubsection{Model Formulation} 
\paragraph*{Sets}
\begin{align}
\label{MIP:Set:S}
S\qquad \text{Set of all Spoil Sections   } s\in S\\
\label{MIP:Set:N}
N\qquad \text{Set  of all Mine Sections } m \in M
\end{align}
Here the sets are used to represent the discretised mine and spoil sections, while these sets have no effect on the system they are used for communication of data and variables. The sizes of sets $S$ and $M$ must be the same as the spoil channel is the results of a prior strip in a mine. The discretisation of the Mine into sections was chosen as the move from a continues model to a discrete model made the modelling of the problem much easier. While some information is lost in this process it is negligible as survey data itself is discrete. The size of the sections themselves are dependant on both survey data and desired accuracy, for the testing of this thesis each section was a metre in length, however if more precision is required then the resolution could be increased. However the increase in detail and resolution will result in slower calculations of block dimensions as more potential solutions are presented. One metre was selected because it was the resolution of the real world data supplied however as seen in the comparison of results a lower resolution will dramatically speed up the run time of the problem, this could be used in first pass solutions to get an approximation of good results. 
\paragraph*{Data}
\begin{align}
\label{MIP:Data:SF}
SF \qquad \text{Swell Factor of Spoil}\\
\label{MIP:Data:Seff}
SEf \qquad \text{Packing Efficiency of Overburden}\\
\label{MIP:Data:SpoilCap}
SpoilCap \qquad \text{Maximum capacity of spoil}\\
\label{MIP:Data:n}
n_{j} \qquad \text{Density of overburden at section $j$} \quad \forall m_{j}  \in M\\
\label{MIP:Data:s}
s_{j} \qquad \text{Density of overburden at section $j$} \quad \forall s_{j}  \in S\\
\label{MIP:Cost}
C_{jk} \qquad \text{Cost of movement from $m_{j}$ to $s_k$ }\\
\label{MIPDvol}
Dvol \qquad \text{Volume of overburden moved in one action}
\end{align}
The data relevant to the formulation of the MIP is modelled and calculated in section 4.1, in this section models and justifications can be made for each design choice that is made in the accuracy of the data however in this section the way that the data is used is much more important. The data used is relatively simple, often represented as either a constant or an array of constants. The use of data \ref{MIP:Data:SF} to represent the swell of spoil is vital to the proper modelling of spoil distribution and will be used whenever interacting with the spoil output of the system, this data is simply a constant value, as suggested in the prior section. Similarly data from \ref{MIP:Data:Seff} is used as a n approximate model for the expansion of the spoil due to inefficiencies in stacking methods, this constant can vary depending on the model used however is simply represented in the formulation of this problem and is not a key data point for initial testing, rather it is important for the accuracy of the spoil channel distribution, which itself is also dependant on data \ref{MIP:Data:SpoilCap} or the maximum capacity of the spoil at any given section $s$, here we assumes that this capacity is constant throughout the spoil channel, however this could be easily adapted if needed for varying capacities. This capacity is used in constraint \ref{MIP:SPcap} as the right hand side of the equation. Sensitivity analysis could be done on this constraint to estimate the potential benefits of increasing the capacity of spoil available, this would have the same effect as increasing the efficiency of the spoil stacking methods, as described by a lower value of data\ref{MIP:Data:Seff}.\\
The amount of material moved per action can be found in data \ref{MIPDvol}, while a very simplistic piece of information it is still necessary to include as it represents the amount of overburden moved per action through the size of the draglines bucket. Sensitivity analysis could also be done to relate how the changing size of this constant affects the mining time of a block, increasing this constraint should reduce the cost of the block as it will reduce the amount of actions required to remove the overburden from a mine section. This cost is found in data \ref{MIP:Cost}however this data is an $m\times s$ array that contains the movement cost from each point $m\in M$ to each spoil section $s \in S$, the movement cost is used in the objective function to minimize the total swing time of the dragline inside a block. This cost data can be calculated as a function $\arctan(\frac{abs(n-s)}{Reach})$ however this may also be pre calculated and put into an array to reduce function calls, the latter method was selected for the implementation of this data. 
\\
The representation of the mine\ref{MIP:Data:n} is an $1\times m$ array where the value at each point is the average amount of overburden to be removed at that point, this value will not change as we will never come back to or refer to a section once the overburden has been removed. Unlike this is data \ref{MIP:Data:s} which represents the amount of overburden currently in the spoil. Once a block is calculated this spoil value is updated so that future blocks use the spoil output of the previous block to have a consistent and proper model for the spoil distribution throughout the strip. Therefore while this data will not change during the calculations performed on the block, once the solution is calculated this data is updated to reflect on the resultant spoil. 
\paragraph*{Variables}
\begin{align}
\label{MIP:M2S}
X_{jk} \qquad \text{Overburden moved from $m_{j}$ to $s_k$ }\\
\label{MIP:MCeil}
Y_{jk} \qquad \text{Actions moving from $m_{j}$ to $s_k$ }
\end{align}
The variables for this model are both related to the movement of overburden from a mount $m$ in the mine to a point $s$ in the spoil. Variable \ref{MIP:M2S} refers to the capacity of dragline volume that is moved from $m$ to $s$. This is necessary for the calculation of spoil capacity constraints as well as the calculation of removal of overburden from the mine at point $m$. However the assumption is made that movement actions taken at any capacity will still incur the same costs. It is for this reason that variable \ref{MIP:MCeil} is used, representing the ceiling of actions taken from point $m$ to point $s$ for all points in the mine. This variable is exclusivly used in the objective function, participating only in constraints that allow it to be linked to \ref{MIP:M2S}.
\paragraph*{Objective}
\begin{align}
\label{MIP:OBJ}
\min\left(\sum_{m\in M}\sum_{s\in S} (C_{n,s}\times Y_{n,s})\right)
\end{align}
The objective function of the Mixed integer linear program is simple, the minimisation of time taken to complete all actions. As some actions will cost more than others it becomes obvious that the cheapest possible movement will be selected when available, it should be noted that while cost\ref{MIP:Cost} is not linear, its relationship with movement actions \ref{MIP:MCeil} is, allowing linear programming to be used. The minimization of this is obvious, as smaller movement actions will take less time than a larger swing action, they will be prefered where feasible. 
\paragraph*{Constraints}
\begin{align}
\label{MIP:RemoveAll}
\sum_{s}X_{m,s}\times Dvol = M_{m}  \quad \forall m\in M  \\
\label{MIP:SPcap}
\sum_{m\in M} X_{m,s}\times SEf \times SF + S_s\leq SpoilCap \quad \forall s \in S \\ 
\label{MIP:Link}
X_{m,s} \leq Y_{\mu,s} \quad \forall m,s \in M,S\\
\label{MIP:Housekeeping}
X_{m,s} \geq 0 \qquad \forall m \in M , s \in S\\
Y_{m,s} \in \mathbb{N} \qquad \forall m \in M , s \in S
\end{align}
The constraints on the model could be considered as the most interesting part of the model, with no constraints the model would simply choose to perform no actions, as this is the minimal allowable solution. Therefore the minimum amount of work done by the dragline must be constrained, the strict constraint found in  equation \ref{MIP:RemoveAll} states that all overburden must be removed from a section $m$ for all sections in the mine. The purpose of this constraint is to set the exact amount of work done by the dragline, it must remove all overburden from the block, but cannot remove any additional material from the block, while the latter is less likely as this would increase the cost of operation it is still best to have as strict a constraint as possible. \\
The constraint described in equation \ref{MIP:SPcap} constrains the solution the most of any constraint in not only the Block model but the entire thesis, it is the feasibility constraint that the spoil capacity cannot be exceeded, it should be noted that this constraint also takes into account the state of the spoil prior to this block, allowing past blocks actions to carry over. This constraint will invalidate many solutions and cause the cost of action to go up if all local spoil sections are at or close to capacity, this constraint is what drives up the cost in the calculation of a block. 
\\ Constraint \ref{MIP:Link} is the linking constraint between $X$\ref{MIP:M2S} and $Y$\ref{MIP:MCeil}, it ensures that $Y$ is the ceiling of $X$. As the objective is a minimisation problem, then $Y$ will seek to be the lowest allowable integer value greater than or equal to $X$, this linking constraint ties constraints \ref{MIP:RemoveAll} and \ref{MIP:SPcap} which are both dependant on $X$ to the objective function \ref{MIP:OBJ} which is dependant on $Y$. Similarly constraints \ref{MIP:Housekeeping} simply state that $X$ must be a positive real number and $Y$ must be an integer greater than or equal to zero, these constraints are simply to properly set up the variables for the model. 
\subsubsection{Implementation}
[Put Code Here]
\begin{lstlisting}[language=Python]
		m = G.Model()
		X = {(n,s):m.addVar() for n in self.N for s in self.S}
		Y = {(n,s):m.addVar(vtype = G.GRB.INTEGER) for n in self.N for s in self.S}
		m.setObjective(G.quicksum((self.MoveCost(n,s)*Y[n,s]) for n in self.N for s in self.S),G.GRB.MINIMIZE)

		CreateCieling = {(n,s):X[n,s]<=Y[n,s] for n in self.N for s in self.S}

		RemoveOnlyallowed = {
		(n):m.addConstr(G.quicksum(X[n,s]*self.Dragline.get_BucketVol() for s in self.S)==self.Mine[n]) for n in self.N
		}

		spoilcapacity = {
		(s):m.addConstr(G.quicksum(X[n,s]*self.Dragline.get_BucketVol()*self.swell*self.expand for n in self.N)+self.Spoil[s]<=self.spoilcap)
		for s in self.S
		}

		m.optimize()
\end{lstlisting}
The implementation of the model is done in python, with use of the gurobi optimisation engine linear programming becomes a very simple method. Lines 2 and 3 are the deceleration of variables relating to the variables found at equations \ref{MIP:M2S}, \ref{MIP:MCeil} corresponding to them exactly. From here the objective is declared and set to minimise , matching the objective \ref{MIP:OBJ} stated in the formulation section. The constraints are also similar with each constraint \ref{MIP:Link},\ref{MIP:SPcap},\ref{MIP:RemoveAll} all represented in code. For additional information on supporting code please refer to Appendix A. Once the formulation is complete gurobi will perform preprocessing on a matrix representation of the model, before using the modified simplex algorithm to solve the linear problem, while this algorithm could be written specifically for this thesis it was seen as unnecessary as the gurobi optimisation engine is much more efficient at this task. 
\\
Once this optimisation algorithm has been completed the spoil is updated and the cost is returned, this is done by simply updating the relevant sections of the array and can be seen completed in the below code snippet.
\begin{lstlisting}[language=python]
self.cost = m.ObjVal
self.potential_spoil = self.Spoil[:self.step]+[sum(M2S[n,s].x*\
self.Dragline.get_BucketVol()*self.swell*self.expand for n in self.N)+self.Spoil[s]\
 for s in self.S]+self.Spoil[self.etemp:]

\end{lstlisting}
This entire process is then wrapped into one function so that the cost of a block can be calculated though one function call, vital to the application of this model in the optimisation of the entire strip. 
\begin{lstlisting}[language=python]
	def BlockCost(self,start,end,Spoil,output=0):
		if end>len(self.Mine):
			end = len(self.Mine)
			# print("Adjusting End Position")
		self.set_Spoil(Spoil)
		if output ==1:
			print("Spoil Set")
		self.set_Block(start, end)
		if output ==1:
			print("Block Set:\t" ,[start,end])
		self.Calc_Valid()
		if output ==1:
			print("Column Generation Done")
		stime = time.time()
		try:
			self.MIP(output)
			etime = time.time()-stime

		except:
			etime = time.time()-stime
			print('\t MIP Infeasible')

			return(np.inf,Spoil,etime)
		if output ==1:
			print("MIP Complete")
		return (self.cost,self.potential_spoil,etime)
		\end{lstlisting}
The only unique or interesting part of this function is that if the block is not feasible then the function will return a cost of infinity, this will mean that the block will not be used in the optimal or feasible soluion of a sequence of blocks in a strip. Each call of the function take in the start, end and state of the spoil, allowing the block to be calculated to return the cost and updated spoil, as well as the time taken to calculate the MIP. Both cost and resulting spoil are vital to the calculation of the strip, and are the two desired outputs of any model describing the actions taken within a block. 
% \subsubsection{Results}
\subsection{Mixed Integer Programming with Validity}
This model is an updated version of the Mixed Integer model with only one added array of data and one additional constraint, however this single constraint makes a huge differences to the complexity and accuracy of the model. The constraint that a dragline cannot move to or reach every point in a block or in the spoil will constraint the areas where overburden can be distributed in the spoil section. This constraint was not initially obvious as typically the dragline will place spoil in local areas rather than in sections that would be out of its reach. However as the availability of spoil room is reduced the cost associated with this action is seen as preferable rather than an infeasible solution. This was only found after an implementation of the strip optimisation was complete, and as such can be seen as an updated model. 
\subsubsection{Model Formulation}
\paragraph*{Additional Data}

\begin{align}
\label{MIP:Data Valid}
Z_{jk}  = \begin{cases} 1& \text{if movement from $n$ to $s$ is valid}\\
0 & \text{Otherwise}   \end{cases} 
\quad \forall n \in N s\in S
\end{align}
This data is an $m\times s$ array of binary values, such that if the dragline is able to feasibly reach the section of spoil when mining the section $m$ of overburden then the arrays value is 1 and 0 otherwise. This array is currently based on the feasible  maximum and minimum reach of the dragline, however other factors such as the pit edge while starting a new block, or having to move over sections in the spoil may cause this array to become more complex. Updating and improving this data should be of high importance for an accurate model, however as it is not integral to how the algorithm works, some simplifications can be made.
\paragraph*{Additional Constraints}
\begin{align}
\label{MIP:Valid}
Y_{n,s}\leq \infty\times Z_{n,s} \qquad \forall n \in N , s\in S
\end{align}
This constraint is a big M constraint, that is it will limit the value of Y unless the value of Z is one for that combination of m and s. This constraint is simply implemented and constrains the feasible solutions of the model, it should be noted that this is setting most of the potential values of Y and X before any optimisation is considered, doing this has a dramatic effect on the reduction of runtime. As less options are available, less calculations must be considered and as such the program can run faster.
\subsubsection{Implementation}
The code for this section is the exact same as previously, however one additional constraint is added, as can be seen below it is very simple to add additional constraints into the gurobi model.
\begin{lstlisting}[language=python]

OnlyifValid = {
		(n,s):m.addConstr(Y[n,s]<= np.inf*self.isValid[n-self.start,s-self.start-self.Dragline.get_reach()]) for n in self.N for s in self.S
		}
\end{lstlisting}
However more interestingly is the calculation of valid blocks, as mentioned previously, the simplistic model for a valid block is if it is within the reach of the dragline, while this is not an accurate model it is sufficient for the demonstration of the block planning algorithm and with more time could be developed to be more fitting for application. 
\begin{lstlisting}[language = python]
def Calc_Valid(self):
	self.isValid = np.zeros((self.end-self.start+1,self.end-self.start+2*self.Dragline.get_reach()+1))
	for i in range(self.end-self.start):
		for j in range(i-self.Dragline.get_reach(),i+self.Dragline.get_reach()):
			self.isValid[i,j+self.Dragline.get_reach()] = 1
\end{lstlisting}
Here the array size is set up, we only consider areas within the block and spoil and as such this will reduce the size of the array and allow for more rapid calculation of results. Once this is done for every possible combination of blocks in this window a check is done to ensure that it is a valid movement. 
% \subsubsection{Results}


\subsection{Dynammic Programming}
\subsubsection{Model Formulation}
\paragraph*{States}
\begin{align}
\label{Stte}
S \quad \text{State of spoil at current stage}
\end{align}
The state of a formulation is the current resources of remaining in a resource constrained dynamic program. Here this is the spoil channel, which will change with every action and therefore is updated at every stage, this state alongside the current stage should be stored in the memory so that the process of memotisation can occur. This technique uses the principle of optimality to reduce the amount of calculations required, that is if we have already calculated the optimal path for the block from this stage with the current states then the solution is already known and that branch of exploration can be completed. However the only state in this formulation is the amount of spoil in each section at the current stage, the use of this state is vital as it is used for the constraint on the actions available at each point. The spoil is a state as it will change with each action, nothing else will change depending on the action taken and therefore all other dynamic variables are simply stages. 
\paragraph*{Stages}
\begin{align}
\label{DP:Stage0}
H \quad \text{Overburden remaining at current block}\\
\label{DP:Stage1}
M \quad \text{current mine section }m \\ 
\label{DP:stage2}
D \quad \text{Position Of Dragline}
\end{align}
The stages of the model are something that we do not have control over, each action moves us from one stage to the next. This formulations two stages are interlinked, however it could also be seen that the position of the dragline is dependant on the current mine section. Therefore the model has effectively two stages, the overburden left at the current section and the current section within the mine. Once all overburden is removed from the stage $H$ the position $M$ is updated. If the position is sufficiently updated then the draglines position also will update. For any given block these stages will occur in the same order no matter what. This is the differentiation between states and stages, the dragline will always move through the block and remove all overburden however the actions taken to remove the overburden will not always be the same. Here the states are selected as the minimum required representation of the block in order to properly model its behaviours and movement process. 	
\paragraph*{Transition Function}
\begin{align}
\label{Transition}
S_{stage+1}(s)=S_{stage+1}(s)\times SEf  \text{where $s$ is the spoil section in action }
\end{align}
The transition value allows the next state to be calculated based on the current state and the action chosen. Here the action chosen is the moment of overburden from the current block to some point on the spoil $s$, this action will succeed in adding additional overburden to the relevant section on the spoil, updating this is simple and from here the only additional piece of information required is the constraint that this transition function cannot create a state that exceeds the spoil capacity, this is done by simply checking the suggested next state and adding a large cost if this constraint is violated. 
\paragraph*{Value Function}
\begin{align}
\label{value}
C_A = \arctan(\frac{abs(D-A)}{Reach})\\
V_t(S_t) = \min (C_A+V_t(S_{t+A}))
\end{align}
The value function calculates the cost associated with a given action based on the cost of the action and the resulting states for all future stages, the cost of an action is simply the swing time from the current block to the spoil selected as an action. This cost is to be minimised however will also affect the state of the next action, as such this will recursively consider all potential courses of action for each action taken. Therefore the more actions that can be made the more computation time is required to calculate the cost of a block. 
\subsubsection{Implementation}
The algorithm mentioned is performed recursively, at each iteration the position of the dragline and current block are updated, as they are stages they are very simple to update. Then the memory is checked to see if a solution already exists for this point. The process taken is simply outlined by the formulation above, but with minor changes to input saturation to take into account any limits on the system.
\begin{lstlisting}[language=python]
_Bucket ={}
M = MineGen(100)
S = [0 for i in range(130)]

def Bucket(Cur,End,SP,M,Scoops,H,D-):
    global _Bucket
    SPtup = str(SP)
    SPmax = 150
    Reach = range(D-20,D+20) 
    if D < 20:
        Reach=range(0,D+20) 
    if D-Cur<=5:
        D = D+5
    if H <=0:
        Cur = Cur+1
        Scoops = 0
        H = M[Cur]
    if Cur == End:
        return (0,0,0,0,[],0)
    if (Cur,End,Scoops,SPtup) not in _Bucket:
        _Bucket[Cur,End,Scoops,SPtup] = min((costspoilNL(Cur,A,H,D)+
            Bucket(Cur,End,SP[:A]+[SP[A]+28]+SP[A+1:],M,Scoops+1,H-10,D)[0],Cur\
                  ,A,Scoops,SP[:A]+[SP[A]+28]+SP[A+1:],D)for A in Reach if\
    SP[A]+28 <= SPmax)
    return _Bucket[Cur,End,Scoops,SPtup]

def GetData(Start,End,Mine,Spoil):
    try:
        A = Bucket(Start,End,Spoil,Mine,0,Mine[0],Start+20)
        Cost = A[0]        
        print("New Spoil Aquired")
        Flag = True
        NewSpoil = _Bucket[max(_Bucket.keys())][4]
        Position = A[5]
        print("Cost Of Block:",A[0])
    except:
        print("Failed")
        Flag = False
        Cost = 100000000000000
        NewSpoil = Spoil
        Position = 0
    return(Cost,NewSpoil,Flag,Position)

\end{lstlisting}
However in the memeotisation it is vital to include the state of the spoil, unfortunately this is likely to be unique and as such will not occur very often, this reduces the amount of memory calls made and the runtime of the program will increase, however if the state is not in the memory then the optimal solution of the problem has no guarantee to be returned, and instead a feasible solution will be supplied. 
% \subsubsection{Results}



\subsection{Comparison of Techniques}

\section{Optimisation of the Strip}
% \subsection{Mixed Integer Programming}
% \subsection{Mixed Integer Programming with Sequence Generation}
% \subsection{Dynamic Programming}
\subsection{Resource Constrained Dynamic Programming}
Resource constrained dynamic programming is the initially obvious solution to the problem, as the mine is explored blocks in a valid range are considered and the current position is updated. The amount of blocks required is not known in advance and therefore a resource constrained dynamic program will find all feasible solutions to this problem alongside the optimal solution. 
\subsubsection{Model Formulation}
\paragraph*{States}
\begin{align}
\label{Stte}
S \quad \text{State of spoil at current stage}
\end{align}
Similarly to the formulation of the cost of a block the spoil capacity at any point is the resource constraining the solution, this is fed into the block cost algorithm in order to properly obtain the optimal solution to the problem, as the spoil is updated creating blocks will become more difficult 
\paragraph*{Stages}
\begin{align}
\label{DP:Stage0}
M \quad \text{current mine section }m 
\end{align}
The stages of the model are something that we do not have control over, each action moves us from one stage to the next. This formulation is the current location of the start of the next block in the model, we consider this as a way of finding our end condition , however the stage is dependant on the actions taken prior, a longer block will result in a stage further on in the mine than usual. The use of a location as a state is vital to the understanding of the formulation. 
\paragraph*{Transition Function}
\begin{align}
\label{Transition}
S_{stage+1}(s)=S_{stage+1}(s)\times SEf  \text{where $s$ is the spoil section in action }
\end{align}
The transition value allows the next state to be calculated based on the current state and the action chosen. Here the action chosen is the movement of overburden from the current block to some point on the spoil $s$, this action will succeed in adding additional overburden to the relevant section on the spoil, updating this is simple and from here the only additional piece of information required is the constraint that this transition function cannot create a state that exceeds the spoil capacity, this is done by simply checking the suggested next state and adding a large cost if this constraint is violated. 
\paragraph*{Value Function}
\begin{align}
\label{value}
C_A = \text{Cost of block length A}\\
V_t(S_t) = \min (C_A+V_t(S_{t+A}))
\end{align}
The value function calculates the cost associated with a given action based on the cost of the action and the resulting states for all future stages, the cost of an action is simply the swing time from the current block to the spoil selected as an action. This cost is to be minimised however will also affect the state of the next action, as such this will recursively consider all potential courses of action for each action taken. Therefore the more actions that can be made the more computation time is required to calculate the cost of a block. 
\subsubsection{Implementation}
\begin{lstlisting}[language = python]
	def DP(self,position,end,spoil):
		self.count +=1
		print("Resource Constrained Dynamic Program \t Called:\t",self.count,'  times')
		print("Distance Remainging  :\t" ,end-position)
		if position>end-self.Dragline.get_minBlock():
			position = end
			# print("FUCK")
			return (10000000000000000000000000,0,[])

		if position == end:
			# print(value, sep, end, file, flush)
			return (0,0,[])
		# if end <= position:
			# self.dict[position,end,str(spoil)] = 100000000
			# return self.dict[position,end,str(spoil)]
		if (position,end,str(spoil)) not in self.dict:
			self.dict[position,end,str(spoil)] = min((10000+self.Blk.BlockCost(position,position+Action,spoil)[0]+
				self.DP(position+Action,end,self.Blk.BlockCost(position,position+Action,spoil)[1])[0]
				,Action,self.Blk.BlockCost(position,position+Action,spoil)[1])
			for Action in range(self.Dragline.get_minBlock(),self.Dragline.get_maxBlock()))
		return self.dict[position,end,str(spoil)]

\end{lstlisting}
\subsection{Resource Constrainted Dynamic Programming with Sequence Generation}
The strongest constraint in the formulation of the strip is that the sum of all blocks must be equal to the length of the strip, that is $\sum B = L_s$, however in the prior formulation this constraint is not considered, this constraint is applied by generating all sequences of potential blocks that will equal the length of the mine. This set of potential solutions is much less than the potential solutions without this constraint and therefore the application of such a constraint will reduce the exploration of the dynammic program, sequence generation is done recursively as seen in the below code snippet 
\begin{lstlisting}[language = python]
def GenBranchs(self,current,end,min,max,past):
	# count = count+1
	# print(count)
		if current == end :
			past+''
			self.Prunedstr.append(past)
			past = ''
			return 1
		if current>end:
			past = ''
			return -1
		for i in range(min,max):
			pred = past + ','+str(i)
			self.GenBranchs(current+i, end, min, max,pred)
		return 0
\end{lstlisting}
Once this is complete the potential solutions are a set of unique solutions to the problem, from here each potential solution is considered by using a forward dynamic program as formulated in the prior section, this modified method is seen below. 
\begin{lstlisting}[language = python]
def PrunedCost(self):
		self.best = np.inf
		self.bestStr = []
		counter = 0
		Flagg = 0
		for solution in tqdm(self.Prunelst):
			# counter+=1
			# print('Percent Complete:\t',counter/len(self.Prunelst)*100,'%')
			for Block in range(len(solution)):
				position = sum([solution[i] for i in range(Block)])
				# print(position,Block,solution)
				combo = ''
				if Block > 0:
					combo = str([solution[i] for i in range(Block)])
				if combo in self.prunedict:
					oldspoil = self.prunedict[combo][1]
					blockcalc = self.Blk.BlockCost(position,position+solution[Block],oldspoil)
					cost = self.prunedict[combo][0]+blockcalc[0]+10000
					# if cost > self.best:
						# Flagg = 1
						# break
				else:
					oldspoil = self.Spoil
					blockcalc = self.Blk.BlockCost(position,position+solution[Block],oldspoil)
					cost = blockcalc[0]+10000
					# if cost > self.best:
						# Flagg = 1
						# break
				newcombo = str([solution[i] for i in range(Block)])
				self.prunedict[newcombo] = [cost,blockcalc[1]]
			self.Prunefinal[str(solution)] = self.prunedict[str([solution[i] for i in range(Block)])]

\end{lstlisting}
\subsection{Comparison of Techniques}




